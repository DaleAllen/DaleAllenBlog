Java线程的实现是基于底层系统的线程机制来实现的,程序中开的线程并不全部取决于JVM虚拟机栈，而是取决于CPU，操作系统，其他进程，Java的版本


- Xms 初始堆大小 (在实际生产中，一般把-Xms和-Xmx设置成一样的。)
- Xmx 最大堆大小
- Xss 每个线程栈大小

每个实例重新创建实例对象,类只加载一次

### 实现 Runnable 接口
- 重写 run()方法
- new Thread(Runnable)
- 调用实例 start()方法

### 继承 thread 抽象类
实际上是实现了 Runnable 接口,进行了封装
重写 run()方法

### 线程状态

- new 创建状态:准备好一个多线程对象
- Runnable 就绪状态:调用了 start(), 等待 cpu 调度
- Running 运行状态:调用 run()方法
- blocked 阻塞状态:暂时停止执行
- terminated 线程销毁

### 调用方法
- start() 启动线程
- run() 线程执行体
- sleep(time) 进入阻塞状态,一段时间;释放锁
- wait(),wait(time) 进入阻塞状态,不释放锁
- yield() 从运行状态失去 cpu 资源,回到就绪状态;只会给大于等于的优先级的线程执行机会;又可以又立即恢复了 cpu 资源,不常用.
- join() 让一个线程等待另一个线程,进入阻塞状态

容易引起死锁:
- stop()
- resume() 恢复
- suspend() 挂起

### 线程优先级
- MAX_PRIORITY 10
- MIN_PRIORITY  1
- NORM_PRIOwRITY 5 默认值
- 优先级高,获取资源的可能性高,仅是个概率
- java 提供的优先级与操作系统优先级并不一定一致,不要直接指定优先级,使用静态变量


### 同步

`线程安全`:线程调度顺序不影响结果
多线程程序中,每个线程拥有独立的`工作内存`,是主内存中的副本.
`原子操作`:不可被中断的一个或一系列操作,在某个时刻,只有一个线程能够执行一段代码
`可见性`:一个线程修改共享变量,对于其他线程可见

`volatile`关键字修饰
- 原理:变量不复制到线程工作内存中,程序直接访问主内存,使变量具有原子性
- 使用条件:适用于修饰布尔,整数,长整数,对象四种数据
- 例外:声明为`volatile`的简单变量如果当前值由该变量以前的值相关，那么volatile关键字不起作用,比如 `i++`
- 使用:在成员变量上使用`volatile`
- 效率:由于使用`volatile`屏蔽掉了VM中必要的代码优化,所以在效率上比较低

### 线程调试

`ps -ef | grep java`
`jps -m` //必须是对应的 java 程序

`top -p <pid>` 输入 H 显示线程

`ps -T -p <pid>` -T 查看线程 -p 执行 pid

`jstack [进程]|grep -A 10 [线程Tid的16进制为nid]`
16进制字母小写
printf "%x\n" 10进制和十六进制转换

`jconsole` 图形
